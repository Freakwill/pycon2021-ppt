# 用...

[TOC]

##  序言(0.5min)

我的题目是"用..."



我学习PEG的动机，简单地说，就是想设计自己的DSL，能够方便个人的生活、学习和工作就很满意。也不指望，自己的作品能被广泛接受。我了解到PEG比形式文法CFG更加容易学习和应用。也希望大家也能去了解PEG。

我用的工具就是今天特别介绍和推荐的Python第三方库，pyparsing

到目前为止，我已经用pyparsing 设计了不少有用的文本解析器。我会在PPT中简单展示一下。



## 0 内容 (0.5min)

这是主要内容。首先我会简单介绍一下PEG；然后讲一下pyparsing怎样实现PEG，也就是，简单讲解一下它的源码，包括主要的类和方法。

再然后，我会展示几个简单的例子，讲一下用pyparsing 设计PEG的技巧和容易出现的错误。

最后，我展示自己的几个比较完整的作品。（也算是我的masterpieces）



## 1 PEG（5min）

### PEG 特点(2min)

PEG的表达式和CFG很相似。但是有它自己的特点。

首先，它是不回溯的。这一点很有意思（也应该着重讲一下），一般形式文法解析文本，一定会进行回溯。然而PEG是不回溯的。一个表达式一旦匹配成功，那么这个表达式连同被匹配的字符串就会被消耗掉。当然人们也可以设计出具有回溯功能的PEG，但这不是今天要讲的内容。接着，它的算法称为递归下降算法。特别适合函数式语言来实现。它的定义也是很严谨的。（严谨的定义会让程序的设计有可靠的依据。）

它的表达式还有一些特点，比如不能出现左递归，还有运算符`|`是不可交换的。（这有点让人意外，因为形式文法和正则表达式里，这是可以交换的）。由于它不回溯，它的解析速度很快，和文本长度呈线性关系。最后，它的Power和CFG相当。CFG可以解析的文本PEG通常也能解析。因此，我们可以用PEG实现任何计算机语言。



### PEG定义(3min)

下面我们来看PEG的具体定义。这是PEG最基本的几个表达式。复杂的表达式和更高级的功能可以在此基础上进行扩展。

PEG其实就是一些映射，这些映射相当于CFG的产生式规则。那我来简单解释一下这些映射的含义。



这是PEG的原子表达式，其功能就是进行字符串匹配。这些是复合表达式。当然还可以定义更复杂的复合表达式。通过递归下降算法，再复杂的解析器最终归结为字符串匹配。

在这里，你会发现`|`确实不能交换。

而且，左递归文法确实不能直接使用。

blahblahblah...



你也可以把解析状态作为PEG解析器的输入变量。比如a(match, s)=a(s), a(fail,s)=(fail,s), 这样解析器就变成解析状态的自同态。还可以在解析状态中存储更丰富的解析信息。每个解析器把旧解析状态映射到新的解析状态，同时返回一些必要的信息。这种映射，用Haskell的术语，称为单子。所以说，（PEG）特别适合用Haskell这类函数是语言实现。

我确实也用Haskell实现了一下（源码也上传了）。奈何自己Haskell水平太菜，到现在都没有调试完bug。真的很无助。(我希望有这方面的专家可以帮助我一下。)



## 2 pyarsing(3min)

好。下面来介绍怎么用pyparsing 写PEG。

你们如果要看源码，那么主要就是看这几个类和方法。ParserElement就是pyparsing的PEG表达式，ParseResult是解析结果的封装，它是一个列表结构和字典结构的复合体。（便于存储和索引信息）`parseString`是最常用的方法。核心的方法是`parseImpl`。`_parse`是内部的封装。调用的顺序是：parseString->_parse->parseImpl。用户要做的就是override `parseImpl`。这个方法就是之前提到的PEG映射关系。



我们来解读一下一个简单的例子。看完这个例子，你就明白pyparsing 解析原理了。

这个类可以说是最简单的，其功能就是在字面上匹配字符串。参数instring就是真个待解析的字符串，loc是当前解析位置，告诉解析器在这个位置之前的字符串已经被consumed了。这样处理显然比原来的定义更加灵活。最后返回解析后的位置，和匹配的结果。如果条件不满足，就报错。如果不区分字符串和字符的话，这个类就是第一个定义。

我想讲完这个例子，应该会让你们更快地熟悉pyparsing。



这里讲个题外话。新版中增加了很多类。其中这个类就是我提议的。你们可以查看pyparsing的github主页的issue，有我和作者的交流。我也给出了自己的实现，功能和原理都差不多（当然我现在已经删了，因为自认为没有他专业）。还有CJK文字，也是我提出的。旧版本是不能解析中文的，但现在可以解析。



## 3 tricks(4min)

### DIY(3min)

#### `Escape` class

这是我设计的简单的子类。它用来识别转义符。我们知道，识别转义符的困难是，即使解析器字面上匹配到了转义符，（匹配到的）也可能不是真正的转义符，比如它前面有真正的转义符，而使自身失去转义符的功能。这个时候就不能算匹配成功。

（我这里写的，可以说是我的神来之笔。）我的处理办法是这样的。首先至少在字面上匹配成功，然后往前看一位，这时只要try一下，从前一位开始是否能成功匹配，如果成功了那就失败了，如果失败了那就成功了。最后记得，把当前的位置和匹配的内容返回。

我觉得这个的定义还是挺专业的。



#### +-*/ expression

这里我实现了一个简单的四则运算表达式的解析器。

用到的是一种称为cascading的设计方法。它的特点是，优先级不同的运算用不同的非终结符。运算符的优先级越低就越靠近cascading的顶层，优先级越高就越靠近cascading的底层，最底层写上原子表达式和一个被括号包含的block（而这个block又回到最顶层，实现递归解析）。

pyparsing实现的时候，基本上就是将PEG表达式翻译成pyparsing的解析器对象。但有几个要注意的地方。首先要注意先设置Forward，避免循环定义变量。（尽管，在PEG中不需要这样写）。然后，要用shift符号，完整定义（cascading）最顶层表达式（此处是不可以用等号）。最后，留意一下，pyparsing重载了Python运算符来实现PEG表达式的组合。



### mistake(1min)

这（就）是一种错误的写法。如果模仿CFG写，那么一定是通不过的。

首先这里出现了循环定义，需要写上Forwad。即使为S写上Forward，也是没有用的。这里致命的错误是左递归。PEG是不能出现左递归的。（至少它的标准的定义是不能出现左递归的。）



## 4 my work(1min)

这些是我的几个比较完整的作品（我的masterpieces）

这个是pyparsing的一些扩展，主要是自定义了一些parsers，试图提供一个构造计算机语言的小型框架。同时还实现了一个计算机语言。

这是是LaTeX中数学表达式的解析器。我还为此写了一篇论文。这个是我试图写一个描述性语言。

当然还有其他小作品。这里就不一一例举了。



这个就是我实现的简单的计算机语言。你会发现，它可以像这样直接定义运算符。



## 5(0.1min)

这些是我主要参考的文献。



## 6(0.5min)

谢谢你们的观看。



这是PPT的链接。上面有这个PPT和一些简单的例子。我会回上传一些小作品，供交流分享。



谢谢~（我的演讲结束了）